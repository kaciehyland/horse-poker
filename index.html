<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>No-Limit Hold'em (Single Player)</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    body { margin: 0; padding: 16px; background: #0b1320; color: #e8eefc; }
    .wrap { max-width: 980px; margin: 0 auto; display: grid; gap: 12px; }
    .row { display: grid; gap: 12px; grid-template-columns: 1.2fr 0.8fr; }
    @media (max-width: 900px){ .row { grid-template-columns: 1fr; } }

    .card { background: #101b2f; border: 1px solid #213052; border-radius: 12px; padding: 12px; }
    h1 { margin: 0 0 6px; font-size: 18px; font-weight: 650; }
    h2 { margin: 0 0 10px; font-size: 14px; font-weight: 650; opacity: 0.9; }

    .table { display: grid; gap: 10px; }
    .board { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    .pill { display: inline-flex; align-items: center; gap: 8px; padding: 6px 10px; border-radius: 999px; background: #0d1627; border: 1px solid #213052; }

    .players { display: grid; gap: 10px; }
    .p { display: grid; grid-template-columns: 1fr auto; gap: 6px; padding: 10px; border-radius: 10px; border: 1px solid #213052; background: #0d1627; }
    .p.me { border-color: #3a66ff; box-shadow: 0 0 0 1px rgba(58,102,255,0.2) inset; }
    .p .name { font-weight: 650; }
    .p .meta { opacity: 0.9; font-size: 12px; }
    .p .right { text-align: right; font-size: 12px; opacity: 0.95; }

    .controls { display: grid; gap: 10px; }
    .btns { display: flex; flex-wrap: wrap; gap: 8px; }
    button {
      appearance: none; border: 1px solid #2b3f6a; background: #142342; color: #e8eefc;
      border-radius: 10px; padding: 10px 12px; font-weight: 650; cursor: pointer;
    }
    button:disabled { opacity: 0.45; cursor: not-allowed; }
    .rangeRow { display: grid; gap: 6px; }
    input[type="range"] { width: 100%; }

    .log { height: 260px; overflow: auto; white-space: pre-wrap; line-height: 1.25; background: #0d1627; border: 1px solid #213052; border-radius: 10px; padding: 10px; }
    .muted { opacity: 0.8; font-size: 12px; }
  </style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <h1>No-Limit Hold’em (You vs 3 Characters)</h1>
    <div class="muted">Single file prototype. Open this file in a browser.</div>
  </div>

  <div class="row">
    <div class="card table">
      <h2>Table</h2>
      <div class="board" id="board"></div>
      <div class="pill" id="potPill">Pot: 0</div>
      <div class="players" id="players"></div>
    </div>

    <div class="card controls">
      <h2>Actions</h2>
      <div class="btns">
        <button id="foldBtn">Fold</button>
        <button id="callBtn">Call</button>
        <button id="raiseBtn">Raise</button>
        <button id="nextHandBtn" disabled>Next hand</button>
      </div>

      <div class="rangeRow">
        <div class="pill">Bet/Raise to: <strong id="amtLabel">0</strong></div>
        <input id="amtRange" type="range" min="0" max="0" value="0" />
        <div class="muted" id="amtHint"></div>
      </div>

      <h2>Log</h2>
      <div class="log" id="log"></div>
    </div>
  </div>
</div>

<script>
(() => {
  // ---------- Helpers ----------
  const sleep = (ms) => new Promise(res => setTimeout(res, ms));
  const byId = (id) => document.getElementById(id);
  const clamp = (x, a, b) => Math.max(a, Math.min(b, x));

  // ---------- Cards ----------
  const SUITS = ["♠","♥","♦","♣"];
  const RANKS = ["2","3","4","5","6","7","8","9","T","J","Q","K","A"];
  const RVAL = Object.fromEntries(RANKS.map((r,i)=>[r, i+2]));

  function makeDeck(){
    const d = [];
    for (const s of SUITS){
      for (const r of RANKS){
        d.push({ r, s, v: RVAL[r], id: r+s });
      }
    }
    return d;
  }

  function shuffle(a){
    for (let i=a.length-1; i>0; i--){
      const j = (Math.random()*(i+1))|0;
      [a[i],a[j]] = [a[j],a[i]];
    }
    return a;
  }

  // ---------- Hand evaluation (5-card) ----------
  // category: 0 high, 1 pair, 2 two pair, 3 trips, 4 straight, 5 flush, 6 full house, 7 quads, 8 straight flush
  function eval5(cards){
    const ranks = cards.map(c=>c.v).sort((a,b)=>b-a);
    const suits = cards.map(c=>c.s);
    const flush = suits.every(s => s === suits[0]);

    // counts
    const cnt = new Map();
    for (const v of ranks) cnt.set(v, (cnt.get(v)||0)+1);
    const groups = [...cnt.entries()].map(([v,c])=>({v,c})).sort((a,b)=> (b.c-a.c) || (b.v-a.v));

    // straight detection (handle wheel A-5)
    const uniq = [...new Set(ranks)].sort((a,b)=>b-a);
    let straightHigh = null;
    if (uniq.length === 5){
      const max = uniq[0], min = uniq[4];
      if (max - min === 4) straightHigh = max;
      else if (uniq[0] === 14 && uniq[1] === 5 && uniq[2] === 4 && uniq[3] === 3 && uniq[4] === 2) straightHigh = 5;
    }
    const straight = straightHigh !== null;

    const nameByCat = [
      "High card","One pair","Two pair","Three of a kind",
      "Straight","Flush","Full house","Four of a kind","Straight flush"
    ];

    let cat = 0;
    let tb = [];

    if (straight && flush){
      cat = 8; tb = [straightHigh];
    } else if (groups[0].c === 4){
      cat = 7;
      const quad = groups[0].v;
      const kicker = groups[1].v;
      tb = [quad, kicker];
    } else if (groups[0].c === 3 && groups[1].c === 2){
      cat = 6;
      tb = [groups[0].v, groups[1].v];
    } else if (flush){
      cat = 5; tb = [...ranks];
    } else if (straight){
      cat = 4; tb = [straightHigh];
    } else if (groups[0].c === 3){
      cat = 3;
      const trip = groups[0].v;
      const kickers = groups.slice(1).map(g=>g.v).sort((a,b)=>b-a);
      tb = [trip, ...kickers];
    } else if (groups[0].c === 2 && groups[1].c === 2){
      cat = 2;
      const p1 = Math.max(groups[0].v, groups[1].v);
      const p2 = Math.min(groups[0].v, groups[1].v);
      const kicker = groups[2].v;
      tb = [p1, p2, kicker];
    } else if (groups[0].c === 2){
      cat = 1;
      const pair = groups[0].v;
      const kickers = groups.slice(1).map(g=>g.v).sort((a,b)=>b-a);
      tb = [pair, ...kickers];
    } else {
      cat = 0; tb = [...ranks];
    }

    return { cat, tb, name: nameByCat[cat] };
  }

  function cmpEval(a,b){
    if (a.cat !== b.cat) return a.cat - b.cat;
    const n = Math.max(a.tb.length, b.tb.length);
    for (let i=0; i<n; i++){
      const av = a.tb[i] ?? 0;
      const bv = b.tb[i] ?? 0;
      if (av !== bv) return av - bv;
    }
    return 0;
  }

  // 7-card best by checking all 21 five-card combos
  function eval7(cards7){
    let best = null;
    const idx = [0,1,2,3,4,5,6];
    for (let a=0; a<7; a++){
      for (let b=a+1; b<7; b++){
        // choose 5 by excluding a,b
        const five = [];
        for (let i=0; i<7; i++) if (i!==a && i!==b) five.push(cards7[i]);
        const e = eval5(five);
        if (!best || cmpEval(e,best) > 0) best = e;
      }
    }
    return best;
  }

  // ---------- Game model ----------
  const BIG_BLIND = 20;
  const SMALL_BLIND = 10;
  const START_STACK = 1000;

  const banter = {
    CALLED: ["Call.", "Sure.", "Alright.", "I’ll see it."],
    RAISED: ["Let’s make it interesting.", "You sure about that?", "Pressure’s on.", "How about a little more?"],
    FOLDED: ["Not worth it.", "You can have that one.", "I’m out.", "Nope."],
    WIN: ["That’ll do.", "Told you.", "Easy.", "Nice and clean."],
    BADBEAT: ["You’ve gotta be kidding.", "Of course.", "Unreal.", "I hate this game."]
  };

  function mkPlayer(seat, name, isHuman, persona){
    return {
      seat, name, isHuman,
      stack: START_STACK,
      hole: [],
      folded: false,
      allIn: false,
      streetBet: 0,
      totalBet: 0,
      persona, // {tight, aggro, bluff}
      lastHandEval: null
    };
  }

  const players = [
    mkPlayer(0, "You", true,  { tight: 0.45, aggro: 0.55, bluff: 0.20 }),
    mkPlayer(1, "Mara", false, { tight: 0.65, aggro: 0.50, bluff: 0.10 }),
    mkPlayer(2, "Holt", false, { tight: 0.45, aggro: 0.70, bluff: 0.25 }),
    mkPlayer(3, "Inez", false, { tight: 0.35, aggro: 0.40, bluff: 0.30 }),
  ];

  const game = {
    dealer: 0,
    deck: [],
    board: [],
    stage: "idle", // preflop/flop/turn/river/showdown
    pot: 0,
    currentBet: 0,
    lastRaiseSize: BIG_BLIND,
    closingSeat: 0,
    actorSeat: 0,
    reveal: false,
    awaitingHuman: null, // resolver for human action
    handOver: false
  };

  // ---------- DOM ----------
  const boardEl = byId("board");
  const potPill = byId("potPill");
  const playersEl = byId("players");
  const logEl = byId("log");

  const foldBtn = byId("foldBtn");
  const callBtn = byId("callBtn");
  const raiseBtn = byId("raiseBtn");
  const nextHandBtn = byId("nextHandBtn");

  const amtRange = byId("amtRange");
  const amtLabel = byId("amtLabel");
  const amtHint = byId("amtHint");

  function log(line){
    logEl.textContent += line + "\n";
    logEl.scrollTop = logEl.scrollHeight;
  }

  function cardText(c){ return c ? (c.r + c.s) : "??"; }

  function computePot(){
    game.pot = players.reduce((s,p)=>s+p.totalBet, 0);
  }

  function activeSeats(){
    return players.filter(p=>!p.folded && !p.allIn && p.stack>0).map(p=>p.seat);
  }

  function inHandPlayers(){
    return players.filter(p=>!p.folded);
  }

  function nextSeatFrom(seat){
    for (let i=1; i<=players.length; i++){
      const s = (seat + i) % players.length;
      const p = players[s];
      if (!p.folded && (!p.allIn) && (p.stack > 0 || p.streetBet > 0)) return s;
      if (!p.folded && p.allIn) return s; // allow pointer to land on all-in (will skip on action)
      if (!p.folded && p.stack === 0) return s;
    }
    return seat;
  }

  function countNotFolded(){
    return players.filter(p=>!p.folded).length;
  }

  function resetForHand(){
    game.deck = shuffle(makeDeck());
    game.board = [];
    game.stage = "preflop";
    game.currentBet = 0;
    game.lastRaiseSize = BIG_BLIND;
    game.reveal = false;
    game.handOver = false;

    for (const p of players){
      p.hole = [];
      p.folded = false;
      p.allIn = false;
      p.streetBet = 0;
      p.totalBet = 0;
      p.lastHandEval = null;
    }
    computePot();
  }

  function dealToPlayers(){
    for (let r=0; r<2; r++){
      for (let i=1; i<=players.length; i++){
        const s = (game.dealer + i) % players.length;
        players[s].hole.push(game.deck.pop());
      }
    }
  }

  function postBlinds(){
    const sbSeat = (game.dealer + 1) % players.length;
    const bbSeat = (game.dealer + 2) % players.length;

    putInBet(players[sbSeat], SMALL_BLIND);
    putInBet(players[bbSeat], BIG_BLIND);

    game.currentBet = BIG_BLIND;
    game.lastRaiseSize = BIG_BLIND;
    game.closingSeat = bbSeat; // action closes at BB if no raise
    game.actorSeat = (bbSeat + 1) % players.length; // UTG
    log(`Blinds posted: ${players[sbSeat].name} ${SMALL_BLIND}, ${players[bbSeat].name} ${BIG_BLIND}`);
  }

  function newStreet(streetName){
    game.stage = streetName;
    for (const p of players) p.streetBet = 0;

    // postflop: first to act is left of dealer, action closes at dealer (if no bet)
    game.currentBet = 0;
    game.lastRaiseSize = BIG_BLIND;
    game.actorSeat = (game.dealer + 1) % players.length;
    game.closingSeat = game.dealer;

    log(`--- ${streetName.toUpperCase()} ---`);
  }

  function burnAndTurn(n){
    game.deck.pop(); // burn
    for (let i=0; i<n; i++) game.board.push(game.deck.pop());
  }

  function putInBet(p, amount){
    const a = Math.min(amount, p.stack);
    p.stack -= a;
    p.streetBet += a;
    p.totalBet += a;
    if (p.stack === 0) p.allIn = true;
    computePot();
  }

  function betTo(p, toAmount){
    // toAmount is total streetBet desired
    toAmount = Math.max(toAmount, p.streetBet);
    const need = toAmount - p.streetBet;
    if (need <= 0) return 0;
    const pay = Math.min(need, p.stack);
    p.stack -= pay;
    p.streetBet += pay;
    p.totalBet += pay;
    if (p.stack === 0) p.allIn = true;
    computePot();
    return pay;
  }

  function canEndBettingRound(){
    // End when:
    // 1) all non-folded, non-all-in players have streetBet == currentBet
    // 2) AND the action has reached the seat after the closing seat
    const seatsToMatch = players.filter(p=>!p.folded && !p.allIn);
    const allMatched = seatsToMatch.every(p => p.streetBet === game.currentBet);
    const nextAfterClosing = (game.closingSeat + 1) % players.length;
    return allMatched && game.actorSeat === nextAfterClosing;
  }

  function maybeAwardUncontested(){
    const alive = players.filter(p=>!p.folded);
    if (alive.length === 1){
      const winner = alive[0];
      winner.stack += game.pot;
      log(`${winner.name} wins uncontested pot of ${game.pot}.`);
      endHand();
      return true;
    }
    return false;
  }

  function endHand(){
    game.handOver = true;
    nextHandBtn.disabled = false;
    foldBtn.disabled = true;
    callBtn.disabled = true;
    raiseBtn.disabled = true;
    amtRange.disabled = true;
    game.reveal = true;
    render();
  }

  // ---------- Side pots + showdown ----------
  function buildPots(){
    const contribLevels = [...new Set(players.map(p=>p.totalBet).filter(x=>x>0))].sort((a,b)=>a-b);
    const pots = [];
    let prev = 0;
    for (const level of contribLevels){
      const involved = players.filter(p=>p.totalBet >= level);
      const amount = (level - prev) * involved.length;

      const eligible = players
        .filter(p=>!p.folded && p.totalBet >= level)
        .map(p=>p.seat);

      pots.push({ amount, eligible });
      prev = level;
    }
    return pots;
  }

  function seatOrderFromLeftOfDealer(){
    const order = [];
    for (let i=1; i<=players.length; i++){
      order.push((game.dealer + i) % players.length);
    }
    return order;
  }

  function showdownAndPayout(){
    game.reveal = true;

    // evaluate hands
    for (const p of players){
      if (p.folded) { p.lastHandEval = null; continue; }
      const seven = [...p.hole, ...game.board];
      p.lastHandEval = eval7(seven);
    }

    const pots = buildPots();
    const order = seatOrderFromLeftOfDealer();

    for (let i=0; i<pots.length; i++){
      const pot = pots[i];
      const elig = pot.eligible.map(s=>players[s]);

      // find best eval among eligible
      let best = null;
      for (const p of elig){
        if (!best || cmpEval(p.lastHandEval, best) > 0) best = p.lastHandEval;
      }
      const winners = elig.filter(p => cmpEval(p.lastHandEval, best) === 0);

      const share = Math.floor(pot.amount / winners.length);
      let rem = pot.amount - share * winners.length;

      for (const w of winners) w.stack += share;

      // distribute remainder by seat order
      for (const s of order){
        if (rem <= 0) break;
        if (winners.some(w=>w.seat===s)){
          players[s].stack += 1;
          rem--;
        }
      }

      const winNames = winners.map(w=>w.name).join(", ");
      log(`Side pot ${i+1}: ${pot.amount} won by ${winNames} (${best.name}).`);
    }

    endHand();
  }

  // ---------- AI ----------
  function preflopScore(hole){
    const a = hole[0].v, b = hole[1].v;
    const hi = Math.max(a,b), lo = Math.min(a,b);
    const pair = (a===b);
    const suited = (hole[0].s === hole[1].s);
    const gap = hi - lo;

    let score = hi + lo*0.5;
    if (pair) score += 8 + hi*0.4;
    if (suited) score += 1.5;
    if (gap === 1) score += 1.5;
    if (gap === 2) score += 0.7;
    if (hi >= 12 && lo >= 10) score += 1.2; // broadways
    return score;
  }

  function postflopScore(p){
    const known = [...p.hole, ...game.board];
    const e = eval7(known.length === 7 ? known : known.concat([]));
    // Rough score: category heavily weighted + tiebreak small
    let score = e.cat * 10;
    score += (e.tb[0] ?? 0) * 0.15;
    score += (e.tb[1] ?? 0) * 0.05;
    return score;
  }

  function aiChooseAction(p){
    const toCall = game.currentBet - p.streetBet;
    const maxTo = p.streetBet + p.stack;

    const persona = p.persona;
    const rnd = Math.random();

    const strength = (game.stage === "preflop") ? preflopScore(p.hole) : postflopScore(p);
    // Normalize-ish
    const s = clamp((strength - 10) / 10, 0, 1); // 0..1-ish

    // thresholds biased by tightness
    const foldThresh = 0.25 + persona.tight*0.35;
    const raiseThresh = 0.55 - persona.aggro*0.15;

    if (toCall > 0){
      if (s < foldThresh && rnd > persona.bluff) return { type: "fold" };

      // decide raise?
      const canRaise = (maxTo >= minRaiseTo());
      const bluff = (rnd < persona.bluff) && (s < raiseThresh);

      if (canRaise && (s > raiseThresh || bluff)){
        const minTo = minRaiseTo();
        const target = clamp(
          Math.floor(minTo + (maxTo - minTo) * (0.15 + persona.aggro*0.35 + Math.random()*0.15)),
          minTo,
          maxTo
        );
        return { type: "raiseTo", to: target };
      }
      return { type: "call" };
    } else {
      // no bet to face
      const canBet = (maxTo >= BIG_BLIND);
      if (canBet && (s > raiseThresh || rnd < persona.bluff*0.6)){
        const minTo = Math.max(BIG_BLIND, p.streetBet + BIG_BLIND);
        const target = clamp(
          Math.floor(minTo + (maxTo - minTo) * (0.10 + persona.aggro*0.30 + Math.random()*0.20)),
          minTo,
          maxTo
        );
        return { type: "raiseTo", to: target }; // bet-to
      }
      return { type: "check" };
    }
  }

  function aiSay(tag){
    const lines = banter[tag];
    if (!lines) return;
    const line = lines[(Math.random()*lines.length)|0];
    log(`  ${line}`);
  }

  // ---------- Betting rules UI helpers ----------
  function minRaiseTo(){
    if (game.currentBet === 0) return BIG_BLIND; // minimum bet size
    return game.currentBet + game.lastRaiseSize;
  }

  function updateActionUI(){
    const me = players[0];
    const toCall = game.currentBet - me.streetBet;

    // If not player's turn or hand over:
    const myTurn = (game.actorSeat === 0) && !game.handOver;
    foldBtn.disabled = !myTurn;
    callBtn.disabled = !myTurn;
    raiseBtn.disabled = !myTurn;
    amtRange.disabled = !myTurn;

    if (!myTurn) return;

    // Label check/call
    if (toCall <= 0) callBtn.textContent = "Check";
    else callBtn.textContent = `Call ${Math.min(toCall, me.stack)}${me.stack < toCall ? " (all-in)" : ""}`;

    // Fold only meaningful if facing a bet; still allow, but you can disable it if you want
    // foldBtn.disabled = !myTurn || toCall<=0;

    // Raise sizing
    const maxTo = me.streetBet + me.stack;
    let minTo;
    if (game.currentBet === 0){
      minTo = Math.max(BIG_BLIND, me.streetBet + BIG_BLIND);
      amtHint.textContent = `Minimum bet is ${BIG_BLIND}.`;
    } else {
      minTo = minRaiseTo();
      amtHint.textContent = `Minimum raise-to is ${minTo} (current bet ${game.currentBet}, last raise size ${game.lastRaiseSize}).`;
    }

    // If you can't reach min raise, disable raise
    if (maxTo < minTo){
      raiseBtn.disabled = true;
      amtRange.min = 0; amtRange.max = 0; amtRange.value = 0;
      amtLabel.textContent = "0";
      amtHint.textContent += " You don't have enough chips to raise; you can only call/fold.";
      return;
    }

    amtRange.min = String(minTo);
    amtRange.max = String(maxTo);

    // keep value in range
    const cur = clamp(Number(amtRange.value||minTo), minTo, maxTo);
    amtRange.value = String(cur);
    amtLabel.textContent = String(cur);

    raiseBtn.textContent = (game.currentBet === 0) ? "Bet" : "Raise";
  }

  // ---------- Rendering ----------
  function render(){
    // board
    boardEl.innerHTML = "";
    const stagePill = document.createElement("span");
    stagePill.className = "pill";
    stagePill.textContent = `Stage: ${game.stage.toUpperCase()}`;
    boardEl.appendChild(stagePill);

    const boardCards = document.createElement("span");
    boardCards.className = "pill";
    boardCards.textContent = `Board: ${game.board.map(cardText).join(" ")}${game.board.length===0 ? " (none)" : ""}`;
    boardEl.appendChild(boardCards);

    const betPill = document.createElement("span");
    betPill.className = "pill";
    betPill.textContent = `Current bet: ${game.currentBet}`;
    boardEl.appendChild(betPill);

    const dealerPill = document.createElement("span");
    dealerPill.className = "pill";
    dealerPill.textContent = `Dealer: ${players[game.dealer].name}`;
    boardEl.appendChild(dealerPill);

    potPill.textContent = `Pot: ${game.pot}`;

    // players
    playersEl.innerHTML = "";
    for (const p of players){
      const div = document.createElement("div");
      div.className = "p" + (p.isHuman ? " me" : "");
      const left = document.createElement("div");
      const right = document.createElement("div");
      right.className = "right";

      const status = p.folded ? "FOLDED" : p.allIn ? "ALL-IN" : "";
      const acting = (game.actorSeat === p.seat && !game.handOver) ? " (acting)" : "";

      left.innerHTML = `
        <div class="name">${p.name}${acting}</div>
        <div class="meta">Stack: ${p.stack} • Street bet: ${p.streetBet} • Total in: ${p.totalBet} ${status ? " • " + status : ""}</div>
      `;

      const showHole = p.isHuman || game.reveal;
      const holeTxt = showHole ? p.hole.map(cardText).join(" ") : "?? ??";
      const handTxt = (game.reveal && p.lastHandEval) ? `\n${p.lastHandEval.name}` : "";
      right.textContent = `Hole: ${holeTxt}${handTxt}`;

      div.appendChild(left);
      div.appendChild(right);
      playersEl.appendChild(div);
    }

    updateActionUI();
  }

  // ---------- Human action promise ----------
  function getHumanAction(){
    return new Promise(resolve => {
      game.awaitingHuman = resolve;
      updateActionUI();
    });
  }

  function clearHuman(){
    game.awaitingHuman = null;
  }

  // ---------- Apply actions ----------
  function applyAction(p, action){
    const toCall = game.currentBet - p.streetBet;

    if (action.type === "fold"){
      p.folded = true;
      log(`${p.name} folds.`);
      if (!p.isHuman) aiSay("FOLDED");
      return;
    }

    if (action.type === "check"){
      log(`${p.name} checks.`);
      return;
    }

    if (action.type === "call"){
      const pay = betTo(p, game.currentBet);
      if (toCall > 0) log(`${p.name} calls ${pay}${p.allIn && pay < toCall ? " (all-in short)" : ""}.`);
      else log(`${p.name} checks.`);
      if (!p.isHuman) aiSay("CALLED");
      return;
    }

    if (action.type === "raiseTo"){
      // Bet or raise-to
      const to = action.to;
      const before = game.currentBet;
      const pay = betTo(p, to);

      // If you couldn't reach the target because of all-in, this becomes "bet/raise to (all-in)".
      const newBet = p.streetBet;

      if (before === 0){
        game.currentBet = newBet;
        game.lastRaiseSize = Math.max(BIG_BLIND, newBet); // first bet sets baseline
        game.closingSeat = p.seat;
        log(`${p.name} bets to ${newBet}.`);
      } else {
        // must be a full legal raise (UI enforces); update raise size
        const raiseSize = newBet - before;
        game.lastRaiseSize = raiseSize;
        game.currentBet = newBet;
        game.closingSeat = p.seat;
        log(`${p.name} raises to ${newBet}.`);
      }

      if (!p.isHuman) aiSay("RAISED");
      return;
    }
  }

  // ---------- Street loop ----------
  async function bettingRound(){
    // move actorSeat until lands on someone who can act (skip folded/all-in)
    const nextActor = () => {
      for (let i=0; i<players.length; i++){
        const s = game.actorSeat;
        const p = players[s];
        if (!p.folded && !p.allIn) return s;
        game.actorSeat = (game.actorSeat + 1) % players.length;
      }
      return game.actorSeat;
    };

    while (true){
      if (maybeAwardUncontested()) return;

      // end condition
      if (canEndBettingRound()){
        log(`Betting round ends.`);
        return;
      }

      nextActor();
      const p = players[game.actorSeat];

      // if everyone left is all-in, end betting immediately
      const canActAnyone = players.some(x=>!x.folded && !x.allIn);
      if (!canActAnyone) return;

      if (p.folded || p.allIn){
        game.actorSeat = (game.actorSeat + 1) % players.length;
        continue;
      }

      render();

      if (p.isHuman){
        const action = await getHumanAction();
        clearHuman();
        applyAction(p, action);
      } else {
        await sleep(450);
        const action = aiChooseAction(p);
        applyAction(p, action);
      }

      // advance to next seat
      game.actorSeat = (game.actorSeat + 1) % players.length;
    }
  }

  // ---------- Hand progression ----------
  async function playHand(){
    nextHandBtn.disabled = true;
    logEl.textContent = "";
    resetForHand();

    dealToPlayers();
    postBlinds();
    render();

    // preflop betting (street bets already include blinds)
    await bettingRound();
    if (game.handOver) return;

    // flop
    burnAndTurn(3);
    newStreet("flop");
    render();
    await bettingRound();
    if (game.handOver) return;

    // turn
    burnAndTurn(1);
    newStreet("turn");
    render();
    await bettingRound();
    if (game.handOver) return;

    // river
    burnAndTurn(1);
    newStreet("river");
    render();
    await bettingRound();
    if (game.handOver) return;

    // showdown
    log("--- SHOWDOWN ---");
    showdownAndPayout();
  }

  // ---------- Wire buttons ----------
  amtRange.addEventListener("input", () => {
    amtLabel.textContent = String(amtRange.value);
  });

  foldBtn.addEventListener("click", () => {
    if (game.awaitingHuman) game.awaitingHuman({ type: "fold" });
  });

  callBtn.addEventListener("click", () => {
    if (!game.awaitingHuman) return;
    const me = players[0];
    const toCall = game.currentBet - me.streetBet;
    if (toCall <= 0) game.awaitingHuman({ type: "check" });
    else game.awaitingHuman({ type: "call" });
  });

  raiseBtn.addEventListener("click", () => {
    if (!game.awaitingHuman) return;
    const to = Number(amtRange.value);
    game.awaitingHuman({ type: "raiseTo", to });
  });

  nextHandBtn.addEventListener("click", async () => {
    if (!game.handOver) return;
    // rotate dealer
    game.dealer = (game.dealer + 1) % players.length;
    await playHand();
  });

  // ---------- Start ----------
  (async () => {
    log("Click Next hand to begin.");
    nextHandBtn.disabled = false;
    foldBtn.disabled = true;
    callBtn.disabled = true;
    raiseBtn.disabled = true;
    amtRange.disabled = true;
    render();
  })();

})();
</script>
</body>
</html>
